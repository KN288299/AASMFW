--- node_modules/react-native-svg/apple/Elements/RNSVGUse.mm
+++ node_modules/react-native-svg/apple/Elements/RNSVGUse.mm.fixed
@@ -7,11 +7,17 @@
  */
 #import "RNSVGUse.h"
 #import <React/RCTLog.h>
+#import "RNSVGNode.h"
 #import "RNSVGSymbol.h"
 
-#ifdef RCT_NEW_ARCH_ENABLED
+#ifndef RCT_NEW_ARCH_ENABLED
+#define RCT_NEW_ARCH_ENABLED 0
+#endif
+
+#if RCT_NEW_ARCH_ENABLED
 #import <React/RCTConversions.h>
 #import <React/RCTFabricComponentsPlugins.h>
+#import <react/renderer/core/ConcreteComponentDescriptor.h>
 #import <react/renderer/components/rnsvg/ComponentDescriptors.h>
 #import <react/renderer/components/view/conversions.h>
 #import "RNSVGFabricConversions.h"
@@ -19,7 +25,7 @@
 
 @implementation RNSVGUse
 
-#ifdef RCT_NEW_ARCH_ENABLED
+#if RCT_NEW_ARCH_ENABLED
 using namespace facebook::react;
 
 - (instancetype)initWithFrame:(CGRect)frame
@@ -134,25 +140,38 @@
 
 - (void)renderLayerTo:(CGContextRef)context rect:(CGRect)rect
 {
-  CGContextTranslateCTM(context, [self relativeOnWidth:self.x], [self relativeOnHeight:self.y]);
-  RNSVGNode *definedTemplate = [self.svgView getDefinedTemplate:self.href];
-  if (definedTemplate) {
-    [self beginTransparencyLayer:context];
-    [self clip:context];
-
-    if ([definedTemplate isKindOfClass:[RNSVGRenderable class]]) {
-      [(RNSVGRenderable *)definedTemplate mergeProperties:self];
+  CGContextSaveGState(context);
+  [self clip:context];
+  [self useRenderNode:context];
+  CGContextRestoreGState(context);
+}
+
+- (void)useRenderNode:(CGContextRef)context
+{
+  RNSVGNode *templateNode = [self.svgView getDefinedTemplate:self.href];
+  if (!templateNode) {
+    RCTLogWarn(@"`Use` element expected a pre-defined svg template as `href` prop, template named: %@ not found.", self.href);
+    return;
+  }
+
+  CGFloat x = [self relativeOnWidth:self.x];
+  CGFloat y = [self relativeOnHeight:self.y];
+  CGFloat width = [self relativeOnWidth:self.usewidth];
+  CGFloat height = [self relativeOnHeight:self.useheight];
+
+  CGRect clipPath = CGRectMake(0, 0, width, height);
+  CGAffineTransform transform = CGAffineTransformMakeTranslation(x, y);
+  CGPathRef path = CGPathCreateWithRect(clipPath, &transform);
+  CGContextAddPath(context, path);
+  CGContextClip(context);
+  CGPathRelease(path);
+
+  // 使用条件编译来处理不同架构下的方法调用
+  #if RCT_NEW_ARCH_ENABLED
+  if ([templateNode isKindOfClass:[RNSVGRenderable class]]) {
+    [(RNSVGRenderable *)templateNode mergeProperties:self];
+  }
+  #else
+  if ([templateNode respondsToSelector:@selector(mergeProperties:mergeList:)]) {
+    [templateNode mergeProperties:self mergeList:self.propList];
+  }
+  #endif
+
+  if ([templateNode isKindOfClass:[RNSVGSymbol class]]) {
+    RNSVGSymbol *symbol = (RNSVGSymbol*)templateNode;
+    [symbol renderSymbolTo:context width:width height:height];
+  } else if ([templateNode class] == [RNSVGGroup class]) {
+    if ([templateNode respondsToSelector:@selector(renderGroupTo:rect:)]) {
+      [templateNode renderGroupTo:context rect:CGRectMake(0, 0, width, height)];
     }
-
-    if ([definedTemplate class] == [RNSVGSymbol class]) {
-      RNSVGSymbol *symbol = (RNSVGSymbol *)definedTemplate;
-      [symbol renderSymbolTo:context
-                       width:[self relativeOnWidth:self.usewidth]
-                      height:[self relativeOnHeight:self.useheight]];
-    } else {
-      [definedTemplate renderTo:context rect:rect];
+  } else {
+    [templateNode renderTo:context rect:CGRectMake(0, 0, width, height)];
+  }
+
+  // 使用条件编译来处理不同架构下的方法调用
+  #if RCT_NEW_ARCH_ENABLED
+  if ([templateNode isKindOfClass:[RNSVGRenderable class]]) {
+    [(RNSVGRenderable *)templateNode resetProperties];
+  }
+  #else
+  if ([templateNode respondsToSelector:@selector(resetProperties)]) {
+    [templateNode resetProperties];
+  }
+  #endif
+}
+
+- (RNSVGPlatformView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
+{
+  CGPoint transformed = CGPointApplyAffineTransform(point, self.invmatrix);
+  transformed = CGPointApplyAffineTransform(transformed, self.invTransform);
+  RNSVGNode const *definedTemplate = [self.svgView getDefinedTemplate:self.href];
+  if (event) {
+    self.active = NO;
+  } else if (self.active) {
+    return self;
+  }
+  RNSVGPlatformView const *hitChild = [definedTemplate hitTest:transformed withEvent:event];
+  if (hitChild) {
+    self.active = YES;
+    return self;
+  }
+  return nil;
+}
+
+- (CGPathRef)getPath:(CGContextRef)context
+{
+  CGAffineTransform transform =
+      CGAffineTransformMakeTranslation([self relativeOnWidth:self.x], [self relativeOnHeight:self.y]);
+  RNSVGNode const *definedTemplate = [self.svgView getDefinedTemplate:self.href];
+  if (!definedTemplate) {
+    return nil;
+  }
+  CGPathRef path = [definedTemplate getPath:context];
+  return CGPathCreateCopyByTransformingPath(path, &transform);
+}
+
+@end
+
+#if RCT_NEW_ARCH_ENABLED
+Class<RCTComponentViewProtocol> RNSVGUseCls(void)
+{
+  return RNSVGUse.class;
+}
+#else
+Class RNSVGUseCls(void)
+{
+  return [RNSVGUse class];
+}
+#endif 